\chapter{Methodology}
To determine the influence of the quality of training data upon the ability of learners to solve the IGGP problem we initially generated the gameplay.

The general game playing community have a codebase that provides the basic functionality for hosting a match between GGP agents\footnote{https://github.com/ggp-org/ggp-base}. This codebase along with the GGP agent Sancho were used to generate the datasets. The codebase includes a very basic random GGP player that will, given a GDL game description, play a random legal move every turn. It uses the GDL description to generate all possible legal moves given the current game state then chooses one uniformly at random. To generate the random traces for a game of $x$ players $x$ random gamers were pitted against one another. The same method was used with Sancho instead of the random gamers to generate the high quality traces.

For each game written in GDL is represented by a set of ground atoms 

Information about games is represented as sets of ground atoms. There exists a set $S$ that represents all atoms that can change from one state to the other. Examples of elements of this set $S$ might be the state of the board in \textit{tic tac toe} along with which player is to take their turn next:
\begin{verbatim}
( control noughts )
( cell 1 1 b ) ( cell 1 2 x ) ( cell 1 3 o )  
( cell 2 1 x ) ( cell 2 2 o ) ( cell 2 3 o )
( cell 3 1 b ) ( cell 3 2 x ) ( cell 3 3 b )
\end{verbatim}
This set of state atoms includes all that can change throughout the game. 

There is also the set of ground atoms representing the actions that can be taken $A$. The moves that each player makes are taken from this set. For a game such as \textit{eight puzzle} these would consist or the atoms \verb|( move i j )| for $0<i\leq 9$ and $0<j\leq 9$ which represent sliding the tile at $(i,j)$ into the space. For \textit{tic tac toe} they would be \verb|( mark i j )| for $0<i\leq 3$ and $0<j\leq 3$ to represent marking a square with the players symbol. To represent a player not making a move we also always have $noop \in A$.
 
We modified the GGP matchmaker to log the following information:
\begin{itemize}
	\item \textbf{Game state trace} - The sequence of game states: $states = (s_1,...,s_n)$ where each $s_i \subseteq S$ is the set of ground atoms true in the $i^{th}$ state.
	\item \textbf{Game roles} - The list of roles of each player in the game: $roles = (r_1,...,r_k)$ e.g. \textit{noughts} and \textit{crosses} in \textit{tic tac toe}
	\item \textbf{Move trace} - The sequence of moves made by each player after each state: $moves = ((m_{1,r_1},...,m_{1,r_k}),...,(m_{n,r_1},...,m_{n,r_k}))$ where $m_{i,r_j} \in A$ is the $i^{th}$ move of player $r_j$. In games where not all players move every turn then $m_{i,r_j}=noop$ shows that $r_j$ made no move
	\item \textbf{Legal move trace} - The sequence of the legal moves for each player in each state:  $legal = ((l_{1,r_1},...,l_{1,r_k}),...,(l_{n,r_1},...,l_{n,r_k}))$. $l_{i,r_j} \subseteq A$ is the set of possible moves for $r_j$ in state $s_i$
	\item \textbf{Goal value trace} - The sequence of goal value for each player on every state: $goals = ((g_{1,r_1},...,g_{1,r_k}),...,(g_{n,r_1},...,g_{n,r_k}))$. $g_{i,r_j} \in [0,100]$ represents how well player $r_j$ has achieved the goal in state $s_i$. For some games such as eight puzzle this is 0 on every state until the winning state where it becomes 100
	
\end{itemize}
This represents all the data needed from the match to generate IGGP tasks. In each state all the positive atoms in $S$ (that is the atoms ture in the current state) are arguments of the \texttt{true} predicate. For example if at the start of the game the first cell is blank on the board then we would have $\texttt{( true ( cell 1 1 b ) )} \in s_1$. 

We define a function that transforms the sequences into four separate induction tasks. An induction task is the set of triples $(B,E^+,E^-)$. We first define a function trace that translates the sequences given in the log of the match into a set of pairs $(B,E^+)$ . We then define a function \textit{triple} which gives the the set of triples  $(B,E^+,E^-)$ from the pairs $(B,E^+)$.

We flatten the sequences of $(m_{i,r_1},...,m_{i,r_k})$ in \textit{moves}, $(l_{1,r_1},...,l_{1,r_k})$ in \textit{legals} and $(g_{1,r_1},...,g_{1,r_k})$ in \textit{goals} to a set that includes the role name as an extra argument of the predicate (the arity is increased by 1). For example if \[(m_{i,r_1},m_{i,r_2}) = \texttt{[( move 2 2 ), ( move 2 3 )]}\] 
and $r_1 = black$ and $r_2 = white$ then it would be replaced by $m_i$
\[m_i = \texttt{\{( move black 2 2 ), ( move white 2 3 )\}}\]

\textit{moves} is now a sequence $(m_1,...,m_n)$. With \textit{legals} a similar intuative flattening procedure is applied
\begin{align*}
(l_{i,r_1},l_{i,r_2}) =\ [&\{\texttt{( move 2 2 ), ( move 1 1 ), ( move 1 3 )}\}, \\
&\{\texttt{( move 2 3 ), ( move 1 2 )}\}]
\end{align*}
and $r_1 = black$ and $r_2 = white$ then it would be replaced by $l_i$
\begin{align*}
l_i = \{&\texttt{( move black 2 2 ), ( move black 1 3 ),}\\ &\texttt{( move white 2 3 ), ( move white 1 2 )}\}
\end{align*}
Again we now have that legals is a sequence $(l_1,...,l_n)$. The same procedure is also applied to \textit{goals}.


The trace function is defined for \textit{legal}, \textit{goal}, \textit{next} and \textit{terminal}. We treat the output of zip as a set. We define $S[p/q]$ on a set $S$ for predicates $p$ and $q$ to be the substitution of all instances of $q$ for $p$. 
\begin{align*}
&\Lambda_{legal} &&= trace_{legal}(states,legal) &&= \text{zip } states\ legal[\texttt{legal}/\texttt{true}] \\
&\Lambda_{goal} &&= trace_{goal}(states,goals) &&= \text{zip \textit{states goal}} \\
&\Lambda_{next} &&= trace_{next}(states,moves) &&= \text{zip \textit{states} } \text{(tail }states[\texttt{next}/\texttt{true}]) \\
&\Lambda_{terminal} &&= trace_{terminal}(states) &&= \text{zip \textit{states t}} \\
&&&\ \ \ \ \textbf{where  } t =\text{take } n\ (\text{repeat } \emptyset ) &&\text{++}\ \ [\{\texttt{( terminal )}\}] \\
&&&\ \ \ \ \textbf{and } n = (\text{length }states) - 1 &&
\end{align*}

The substitutions $[\texttt{legal}/\texttt{true}]$ and $[\texttt{next}/\texttt{true}]$ ensure that all positive examples in $E^+$ are in the relevant predicate. That is, we need all the \texttt{move} atoms in $legal$ to be inside the \texttt{legal} predicate:
\[\texttt{( legal ( move 1 1 ) )}\]
Since the predicates are already in the \texttt{true} predicate we only need to substitute one out for the other.

Some of the ILP systems being tested cannot work with function symbols of arity greater than 0. To allow them to operate we merge the function and their arguments into one predicate. For example \texttt{( legal ( move 1 1 ) )} becomes \verb|( legal_move 1 1 )| where \verb|legal_move| is a newly formed predicate.

Let $pred s p$ be the subset of atoms in $s$ that use the predicate $p$. For example when $s_{legal}\ S\ E^+$ is called with 
\[X = \{\texttt{( move 1 1 ), ( move 1 2 ), ( move 2 1 ), ( move 2 2 )}, ...\}\] 
and 
\[E = \{ \texttt{( move 1 1 ), ( move 1 2 )}\}\]
then 
\[s_{legal}\ X\ E = \{\texttt{( move 2 1 ), ( move 2 2 )}\}\]
To generate the triples we use the two functions $triples_1$ and $triples_2$.
\begin{align*}
tri&ple_1(\Lambda_p) = \text{map } f\ \Lambda \\
&\textbf{where } f\ (B,E^+) = (B,E^+,(pred\ S\ p) - E^+)\\
tri&ple_2(\Lambda_p) = \text{map } f\ \Lambda \\
&\textbf{where } f\ (B,E^+) = (B,E^+,(pred\ A\ p) - E^+)
\end{align*}
We generate the IGGP task with $triples_1$ and $triples_2$ as below:
\[\Delta = triples_1(\Lambda_{goal}) \cup triples_1(\Lambda_{terminal}) \cup triples_2(\Lambda_{next}) \cup triples_2(\Lambda_{legal})\]

