\documentclass[a4paper,12pt]{report}
\usepackage{float,graphicx}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{minted}
\usepackage{mathrsfs}
\usepackage{pgfplots}
\usepackage[lined,boxruled]{algorithm2e}\usepackage{color}
\usepackage[english]{babel}

\newcommand{\ac}[1]{\textcolor{red}{AC: #1}}
\newcommand{\af}[1]{\textcolor{blue}{AF: #1}}

\pgfplotsset{width=10cm,compat=1.9}
\usemintedstyle{friendly}

\begin{document}
\title{\Large{\textbf{Inducing game rules from varying quality game play}}}
% \title{\Large{\textbf{Inductive general game playing with varying quality game play}}}
\author{Alastair Flynn}
\maketitle

\input{00-abstract}
\input{01-intro}
\input{02-related}

\chapter{Logical setting}\label{LogicalSetting}
    - What precisely is the problem?
    - You can paraphrase a lot from the IGGP paper

The IGGP problem is defined in the 2019 paper Inductive General Game Playing \cite{Cropper/IGGP}. Much like the problem of ILP \ref{sec:ILP} the problem setting consists of examples about the truth or falsity of a formula $F$ and a hypothesis $H$ which covers $F$ if $H$ entails $F$. We assume the languages of:
\begin{itemize}
\item $\mathscr{E}$ the language of examples (observations)
\item $\mathscr{B}$ the language of background knowledge
\item $\mathscr{H}$ the language of hypotheses
\end{itemize} Each of these languages can be see as a subset of those described in \ref{sec:ILP}. All the predicates involved in the task are taken from the GDL descriptions of games in the Stanford GGP* library. A lot of the atoms in the descriptions are not function-free, that is, they are nested predicates. For example \mintinline{Prolog}{true(count(9))}. We flatten all of these to single, non nested predicates, i.e. \mintinline{Prolog}{true_count(9)}. This is done because some ILP systems do not support function symbols. We can therefore assume that both $\mathscr{E}$ and $\mathscr{B}$ are function-free. The language of hypotheses $\mathscr{H}$ can be assumed to consist of datalog programs with stratified negation as described here\cite{Kenneth}. Stratified negation is not necessary but in practice allows significantly more concise programs, and thus often makes the learning task computationally easier. We first define an IGGP input the use it to define the IGGP problem. An IGGP input needs to capture the idea of an observation about a game. The input is based on the general input for the Logical induction problem of section \ref{sec:ILP} since this is a sub problem of it.

\textbf{The IGGP Input:} An input $\Delta$ is a set of triples $\{(B_i,E_i^+,E_i^-)\}_m^{i=1}$ where
\begin{itemize}
\item $B_i \subset \mathcal{B}$ represents background knowledge
\item $E_i^+ \subseteq \mathscr{E}$ and $E_i^- \subseteq \mathscr{E}$ represent positive and negative examples respectively
\end{itemize}
An IGGP input forms the IGGP problem:

\textbf{The IGGP Problem:} Given an IGGP input $\Delta$, the IGGP problem is to return a hypothesis $H \in \mathscr{H}$ such that for all $(B_i,E_i^+,E_i^-) \in \Delta$ it holds that $H \cup B_i \models E_i^+$ and
$H \cup B_i \models E_i^-$.


\subsubsection{Problem Setting}
Let the accuracy of a set $I$ of ILP systems in problem setting be defined as the mean of the percentage accuracy of each of them when tested on a given set of examples.

- Given an set of ILP systems $I$, for what selection of game traces $\Delta$ combined from an optimal gameplay distribution and a random gameplay distribution are the systems most accurate when solving the IGGP problem. The accuracy of $I$ when solving the IGGP problem will be tested by evaluating each $i \in I$ with data taken from a 50/50 combination of both optimal and random distributions.

We will also be investigating how the size of the trace set $|\Delta|$ affects the accuracy of the hypothesis $H$.

\subsection{Sancho}
To generate optimal gameplay we decided that the best approach was to use a previous winner of the GGP competition. Since the aim of the competition is to find the program that performs best at the set of games used in the IGGP problem we conclude that there is no better way to generate a comprehensive set of game traces. The winner of the 2014 GGP competition 'Sancho' was selected \footnote{http://ggp.stanford.edu/iggpc/winners.php accessed on 12/03/2020} since they are the most recent winner to have published their code \footnote{http://sanchoggp.github.io/sancho-ggp/ access 12/03/2020}. Some small modifications to the information logged by the game server are made but otherwise the code is unchanged.

The core of Sancho is the Monte Carlo tree search (MCTS) algorithm.

\subsubsection{Monte Carlo Tree Search}
Given a game state the basic MCTS will return the most promising next move. The algorithm achives this by simulating random playouts of the game many times. The technique was developed for computer Go but has since been applied to play a wide range of games effectively including board games and video games\cite{Silver/MCTS}\cite{Chaslot/MCTS}.

The use of random simulation to evaluate game states is a powerful tool. Information about the game such as heuristics for evaluating non terminal states are not needed at all, the rules of the game are enough on their own. In the case of the GGP problem this is ideal. The rules of the game are only revealed shortly before the game is played meaning deriving effective heuristics is a hard problem.

In our case all games being played are sequential, finite and discrete so we only need to consider MCTS for this case.
%say why it is good for this

% possibly put in a diagram of game tree
The MCTS is a tree search algorithm, the tree being searched is the game tree. A game tree being a tree made up of nodes representing states of the game and the children of each node being all the states that can be moved to from that state. The leaves of this tree are the terminal states. The search is a sequence of traversals of the game tree. A traversal is a path that starts at the root node and continues down until it reaches a node that has at least one unvisited child. One of these unvisited children are then chosen to be the start state for a simulation of the rest of the game. The simulation chooses random moves, playing the game out to a terminal state. The result of the simulation is propagated back from the node it started at all the way to the root node to update statistics attached to each node. These statistics are used to choose future paths to traverse so more promising moves are investigated more.

Exactly how the tree search algorithm chooses new nodes to simulate is where the complexity lies. The node chosen by traversal of the tree should strike a balance between exploiting promising nodes and exploring nodes with few simulations. The Upper Confidence Bound for trees algorithm was designed to do exactly this\cite{Kocsis/UCT}. The algorithm chooses a child node for each state based on the UTC formula. The formulae can be written as: \[UTC(v_i) = \frac{Q(v_i)}{N(v_i)} + c\sqrt{\frac{ln(N(v_i))}{N(v_i)}}\] Where we have:
\begin{itemize}
\item $v_i$ is node $v$ after move $i$
\item $Q(v)$ is the number of winning simulations that have taken place below it
\item $N(v)$ is the number of simulations that have taken place below it
\end{itemize}
The function is the sum of two components. $\frac{Q(v_i)}{N(v_i)}$ is called the exploitation component. It is a ratio of winning to loosing simulation that resulted from making this move. This encourages traversal of promising nodes that have a high win rate. However, if only this factor was used the algorithm would quickly find a winning node and only explore that hence we need a second component: the exploration factor. $c\sqrt{\frac{ln(N(v_i))}{N(v_i)}}$ favours nodes that have not yet been explored. The value $c$ is a constant that balances the two components, it can be adjusted depending on the use case.

Sancho makes a few modifications to MCTS\footnote{https://sanchoggp.blogspot.com/2014/05/what-is-sancho.html accessed on 15/03/2020}, the main one being adding of heuristics. The tree is also replaced with a more general graph which allows for transitions between lines of play without duplication of states. There are other modifications to increase efficiency.

In GGP matches a period of time before the match is given in which to do pre match calculations. Sancho uses this period to derive basic heuristics and optimise the value of $c$ in the formulae. A heuristic should take a game state or move and return a value based on how promising that state or move is in relation to the goal state. To take the heuristics into account when choosing the next state to explore each node (state) $v$ is seeded with a heuristic value on creation.

The identification of possible heuristics takes place in two stages. The first of these is static analysis of the game rules. This static analysis identifies possible heuristics that can be applied to the current game. These include things like piece capture: if certain rules indicate capture of a piece these can be selected against, or numeric quantity detection: a number in the state acts as a heuristic (like number of coins a player has). The second stage is simulation of the game. Many (possibly tens of thousands) of full simulations of the game are run. After the simulations are complete a correlation coefficient is calculated between each candidate heuristic's observed values and the eventual score achieved in the game. Those heuristics that show correlation above a fixed threshold are then enabled, and will be used during play.

\chapter{ILP systems used}
We use three ILP systems to compare the effects of different learning data, Metagol, Aleph and ILASP. All three systems use different approaches the ILP problem.
\section{Metagol}

\section{ALEPH}
Aleph is an Prolog variant of the ILP system Progol \cite{Muggleton/Aleph}. As input, like any other ILP system, Aleph takes positive and negative examples represented as a set of facts along with the background knowledge. It also requires \textit{mode declarations} and \textit{determinations} which are specific to Aleph. Mode declarations specify the type of the inputs and outputs of each predicate used e.g. \texttt{plus(+integer,+integer,-integer)} where \texttt{+} signifies an input and \texttt{-} an output.
Determinations specify which predicates can go in the body of a hypothesis. These determinations take the form of pairs of predicates, the first being the head of the clause and the second a predicate that can appear in its body.

For each predicate we would like to learn in the IGGP problem we give Aleph the determinations consisting of every target predicate (next,goal and legal) paired with every background predicate (which are specific to each game). Luckily there has been some work to induce mode declarations from the determinations \cite{McCreath/Meta-extraction} so we do not need to come up with our own mode declarations.

A basic outline of the Aleph algorithm is taken from the aleph website \footnote{http://www.cs.ox.ac.uk/activities/programinduction/Aleph/aleph.html accessed 26/03/2020}:
\begin{enumerate}
\item Select an example to be generalised. If none exist, stop, otherwise proceed to the
next step.
\item Construct the most specific clause (also known as the bottom clause \cite{Muggleton/Aleph}) that entails
the example selected and is within language restrictions provided.
\item Search for a clause more general than the bottom clause. This step is done by search-
ing for some subset of the literals in the bottom clause that has the 'best' score.
\item The clause with the best score is added to the current theory and all the examples
made redundant are removed. Return to step 1.
\end{enumerate}

Mode declarations and determinations are used in step 2 of this procedure to bound the hypothesis space. Only predicates that are mentioned in the determinations of the hypothesis and are of the correct type are tried. The bottom clause constructed is the most specific clause that entails the example. Therefore a clause with the same head and any subset of the predicates of the body will be more general than the bottom clause. Aleph only considers these generalisations of this bottom clause. The search space is therefore bounded by $2^n$ with $n$ being the number of predicates in the bottom clause.

By default Aleph preforms a bounded breath first search on all the possible rules, enumerating shorter clauses before longer clauses. The search is bounded by several parameters such as maximum clause size and maximum proof depth. The best score is selected as the one with the best $P - N$ value where $P$ is the number of positive rules entailed by the hypothesis and $N$ is the number of negative rules entailed. For this paper we will use Aleph with the default settings.

\section{ILASP}
\chapter{Implementations}
\section{Eight Puzzle}
To write an optimal player for Eight Puzzle I decide to use an approach based on best first search.
\subsection{Best first search}
Best first search generates a graph of the game states, expanding the most promising nodes first according to a heuristic for how close to the goal state the current state is. When the goal node is reached the search gives the path from the root node to it, i.e. the list of moves made to get to the goal.
Since Best first search is a well know and often used algorithm in Prolog we decided to use a standard implmentation from Bratko\cite{Bratko}. This decision was made to avoid needless mistakes and inefficiency that would have come with a new independent implementation of this algorithm.

Best First search is a generic algorithm that needs certain problem specific predicates to be implemented for it to function. These predicates are:
\begin{itemize}
\item \textbf{The successor predicate - }\mintinline{Prolog}{s(Node,Node1,Cost)}: This predicate is true if there is an arc costing \mintinline{Prolog}{Cost} between state \mintinline{Prolog}{Node} and state \mintinline{Prolog}{Node1}. In Eight Puzzle we set the cost of all arcs to be 1.
\item \textbf{The Goal predicate - }\mintinline{Prolog}{goal(Node)}: This is true if the state \mintinline{Prolog}{Node} is a goal state.
\item \textbf{The heuristic - }\mintinline{Prolog}{h(Node,H)}: This is a relation that relates a state \mintinline{Prolog}{Node} to a value \mintinline{Prolog}{H} that is a heuristic for how close to the state is to the goal state.
\end{itemize}
To represent the board I decided to use a 9 element list with \mintinline{Prolog}{b} representing the blank tile INSERT IMAGE OF GOAL BOARD \mint{Prolog}{[1,2,3,4,5,6,7,8,b]}.
I defined some useful helper predicates to start with. The Manhatten distance between two tiles between two tiles is the difference in X coordinates plus the difference in Y coordinates, I wrote a predicate to calculate this relation:
\begin{minted}{Prolog}
mandist(X1-Y1,X2-Y2,D) :-
    diff(X1,X2,Dx),
    diff(Y1,Y2,Dy),
    D is Dx+Dy.
\end{minted}
I also wrote predicates to calculate the coordinates of a tile from its position in the list, one that relates two tiles if they are next to each other on the grid and one that gives the position in the list of the blank tile.
\subsubsection{Successor}
To define the successor predicate I decided the best way to do it was to relate two boards by swapping the blank tile with its neighbours. I first wrote a function swap:
\begin{minted}{Prolog}
swap(I,J,L1,L3) :-
   same_length(L1,L3),
   append(BeforeI,[AtI|PastI],L1),
   append(BeforeI,[AtJ|PastI],L2),
   append(BeforeJ,[AtJ|PastJ],L2),
   append(BeforeJ,[AtI|PastJ],L3),
   length(BeforeI,I),
   length(BeforeJ,J).
\end{minted}
This function only uses built in predicates that all do the obvious thing. In the first two appends this rule takes L1 and replaces the element I with the element J to make list L2 then in the second two takes list L2 and replaces J with I to make list L3. The variable AtI and AtJ will be instantiated with the elements at index I and J because of the restriction on the length of the sublist before them at the end of the rule.
The successor function is defined as:
\begin{minted}{Prolog}
s(B1,B2,1) :-
    member(N,B1),
    nth0(NI,B1,N),
    blank_pos(B1,BI),
    neighbor(BI,NI),
    swap(BI,NI,B1,B2).
\end{minted}
Since all arc (move) costs in my version of Eight Puzzle are 1 the predicate is only true when Cost is 1. \mintinline{Prolog}{member(N,B1)} is true when N is a member of B1. Here it restricts N to values on the board. \mintinline{Prolog}{nth0(NI,B1,N)} sets NI to the index of the value N in the list B1, i.e. it tells us the position on the board of the value we are considering. \mintinline{Prolog}{blank_pos(B1,BI)} sets BI to the position on the board of the blank. \mintinline{Prolog}{neighbor(BI,NI)} is true if the positions BI and NI are next to each other on the board. If all of these are true we then instantiate B2 with the new board by swapping the blank and its neighbour.
\subsubsection{Goal}
Defining the goal was actually very simple, I added the predicate: \mint{Prolog}{goal([1,2,3,4,5,6,7,8,b])}
\noindent This is all that is needed to define the goal state.
\subsubsection{Heuristic}
A good heuristic for Eight Puzzle needs to capture an estimate of the distance of the current state from the goal. I initially decided to use the sum of the Manhattan distances of each tile from its position in the goal state. To calculate this I wrote a predicate \mintinline{Prolog}{totdist(L,Goal,N)} which relates a board L, a goal Goal and the sum of the Manhattan distances N.
\begin{minted}{Prolog}
totdist(L,Goal,N) :-
    totdist1(L,Goal,N,0).

totdist1([],_Goal,0,_Pos).

totdist1([b|T],Goal,N,Pos) :-
    !,Pos1 is Pos + 1,
    totdist1(T,Goal,N,Pos1).

totdist1([V|T],Goal,N,Pos) :-
    nth0(I,Goal,V),
    coord(Pos,X1-Y1),
    coord(I,X2-Y2),
    mandist(X1-Y1,X2-Y2,D),
    Pos1 is Pos + 1,
    totdist1(T,Goal,N1,Pos1),
    N is N1 + D.
\end{minted}
My implementation of this predicate iterates through the list working out the Manhattan distance for each tile. When iterating through the list the way to keep track of how far through it you are (the position on the board you are currently looking at) is use a separate variable as a counter. Here I used Pos.
After testing my program with this heuristic I found that it took about 6 seconds to come up with the first solution. I decided that I could probably do better if I had another heuristic that I combined with the Manhattan distance. I decided to use the number of tiles that were out of the row and/or column they were in. I wrote a predicate \mintinline{Prolog}{outofpos(B,Goal,N,Pos)} that relates the board and the goal to the number of tiles out column plus the number of tiles out of row.
\begin{minted}{Prolog}
outofpos([],_Goal,0,_Pos).

outofpos([b|T],Goal,N,Pos) :- !,
    Pos1 is Pos + 1,
    outofpos(T,Goal,N,Pos1).

outofpos([V|T],Goal,N,Pos) :-
    coord(Pos,X1-Y1),
    nth0(PosG,Goal,V),
    coord(PosG,X2-Y2),
    Pos1 is Pos + 1,
    outofpos(T,Goal,N1,Pos1),
    (   xandy(X1 = X2, Y1 = Y2) ->
        N is N1
    ;   xory(X1 = X2, Y1 = Y2) ->
        N is N1 + 1
    ;   N is N1 + 2
    ).

xandy(X,Y) :- X,Y.
xory(X,Y) :- X;Y.
\end{minted}
This predicate iterates through the board and for each tile looks at the place it is on the goal board and checks which coordinates match. If both match then it is the right column and row so the total remains the same, otherwise it is incremented. I eventually found that the heuristic the worked the fastest was Manhattan distance total + 2 * number of tiles out of position. I wrote this predicate for the heuristic:
\begin{minted}{Prolog}
h(B,H) :-
    goal(Goal),
    totdist(B,Goal,D),
    outofpos(B,Goal,N,0),
    H is D + (2*N).
\end{minted}

\section{Noughts and crosses}
\chapter{Experiments}
\section{Optimal Play vs Random with fixed sample size}
\section{Mixed datasets (50/50 random and optimal)}
\subsection{Results}
\begin{center}
\begin{tabular}{| l | l | l | l | l |}
\hline
Training Data & Testing Data & Predicate & Metagol & Aleph \\ \hline
\end{tabular}
\end{center}
\subsubsection{Random training and testing}
metagol
\\
\begin{tabular}{lrrrr}
\hline
 game               &   next &   goal &   legal &   terminal \\
\hline
 alquerque          &     51 &     50 &      50 &        100 \\
 asylum             &     50 &     50 &      50 &        100 \\
 battle\_of\_numbers  &     54 &     50 &      50 &        100 \\
 breakthrough       &     50 &     50 &      50 &        100 \\
 buttons\_and\_lights &     50 &     50 &      50 &        100 \\
 duikoshi           &     50 &     50 &      50 &        100 \\
 eight\_puzzle       &     55 &     50 &      50 &        100 \\
 freeforall         &     54 &     50 &      50 &        100 \\
 hexforthree        &     51 &     50 &      50 &        100 \\
 horseshoe          &     57 &     50 &      50 &        100 \\
 hunter             &     52 &     50 &      50 &        100 \\
 knights\_tour       &     50 &     50 &      50 &        100 \\
 kono               &     52 &     50 &      50 &        100 \\
 pentago            &     51 &     50 &      50 &         50 \\
 pilgrimage         &     50 &     50 &      50 &        100 \\
 rainbow            &     50 &     50 &      50 &        100 \\
 sudoku             &     50 &     50 &      50 &         50 \\
 sukoshi            &     50 &     50 &      50 &        100 \\
 untwisty\_corridor  &     62 &     50 &      50 &        100 \\
\hline
\end{tabular}
\\
aleph
\\
\begin{tabular}{lrrrr}
\hline
 game               &   next &   goal &   legal &   terminal \\
\hline
 alquerque          &     56 &     95 &      50 &        100 \\
 asylum             &     52 &     99 &      50 &        100 \\
 battle\_of\_numbers  &     68 &     98 &      76 &        100 \\
 breakthrough       &     51 &     75 &      50 &        100 \\
 buttons\_and\_lights &    100 &     75 &      50 &        100 \\
 duikoshi           &     90 &     83 &      90 &        100 \\
 eight\_puzzle       &     96 &     99 &      84 &        100 \\
 freeforall         &     98 &     98 &      76 &        100 \\
 hexforthree        &     67 &     99 &      72 &        100 \\
 horseshoe          &     93 &     97 &      97 &        100 \\
 hunter             &     95 &     98 &      99 &        100 \\
 knights\_tour       &     98 &     99 &      99 &        100 \\
 kono               &     94 &     98 &      95 &        100 \\
 pentago            &     98 &     83 &      98 &        100 \\
 pilgrimage         &     97 &     98 &      83 &        100 \\
 rainbow            &     93 &     75 &      70 &        100 \\
 sudoku             &     95 &     75 &      50 &        100 \\
 sukoshi            &     87 &     75 &      90 &        100 \\
 untwisty\_corridor  &    100 &     75 &      50 &        100 \\
\hline
\end{tabular}
\\
specialised ilasp
\\
\begin{tabular}{lrrrr}
\hline
 game               &   next &   goal &   legal &   terminal \\
\hline
 alquerque          &     46 &     90 &      99 &        100 \\
 asylum             &     69 &     99 &      83 &        100 \\
 battle\_of\_numbers  &     54 &     97 &      88 &        100 \\
 breakthrough       &     56 &     50 &     100 &         50 \\
 buttons\_and\_lights &    100 &     50 &       0 &        100 \\
 duikoshi           &     85 &     66 &      60 &        100 \\
 eight\_puzzle       &     96 &     98 &      75 &        100 \\
 freeforall         &     76 &     71 &      85 &        100 \\
 hexforthree        &     83 &    100 &     100 &        100 \\
 horseshoe          &     93 &     95 &      96 &        100 \\
 hunter             &     71 &     99 &      83 &        100 \\
 knights\_tour       &     83 &     98 &      95 &        100 \\
 kono               &     83 &     97 &      98 &        100 \\
 pentago            &     99 &     42 &      83 &        100 \\
 pilgrimage         &     92 &     96 &      89 &         96 \\
 rainbow            &     87 &     50 &      27 &        100 \\
 sudoku             &     84 &     50 &      10 &        100 \\
 sukoshi            &   -100 &     50 &      81 &        100 \\
 untwisty\_corridor  &    100 &     50 &       0 &       -100 \\
\hline
\end{tabular}

\subsection{Optimal res}
\begin{tabular}{llrrr}
\hline
 game               & predicate   &   metagol &   aleph &   specialised\_ilasp \\
\hline
 alquerque          & next        &        51 &      90 &                  47 \\
 alquerque          & goal        &        50 &      95 &                  90 \\
 alquerque          & legal       &        50 &      50 &                  99 \\
 alquerque          & terminal    &       100 &     100 &                 100 \\
 asylum             & next        &        50 &      52 &                  49 \\
 asylum             & goal        &        50 &      99 &                  99 \\
 asylum             & legal       &        50 &      50 &                  99 \\
 asylum             & terminal    &       100 &     100 &                 100 \\
 battle\_of\_numbers  & next        &        53 &      65 &                  75 \\
 battle\_of\_numbers  & goal        &        50 &      98 &                  97 \\
 battle\_of\_numbers  & legal       &        50 &      76 &                  88 \\
 battle\_of\_numbers  & terminal    &       100 &     100 &                 100 \\
 breakthrough       & next        &        50 &      90 &                  90 \\
 breakthrough       & goal        &        50 &      75 &                  50 \\
 breakthrough       & legal       &        50 &      50 &                  87 \\
 breakthrough       & terminal    &       100 &     100 &                  65 \\
 buttons\_and\_lights & next        &        50 &     100 &                 100 \\
 buttons\_and\_lights & goal        &        50 &      75 &                  50 \\
 buttons\_and\_lights & legal       &        50 &      50 &                   0 \\
 buttons\_and\_lights & terminal    &       100 &     100 &                 100 \\
 duikoshi           & next        &        50 &      90 &                  87 \\
 duikoshi           & goal        &        50 &      83 &                  66 \\
 duikoshi           & legal       &        50 &      91 &                  69 \\
 duikoshi           & terminal    &       100 &     100 &                 100 \\
 eight\_puzzle       & next        &        55 &      96 &                  88 \\
 eight\_puzzle       & goal        &        50 &      99 &                  50 \\
 eight\_puzzle       & legal       &        50 &      84 &                  68 \\
 eight\_puzzle       & terminal    &       100 &     100 &                 100 \\
 freeforall         & next        &        55 &      98 &                  74 \\
 freeforall         & goal        &        50 &      98 &                  71 \\
 freeforall         & legal       &        50 &      76 &                  97 \\
 freeforall         & terminal    &       100 &     100 &                 100 \\
 hexforthree        & next        &        51 &      67 &                  83 \\
 hexforthree        & goal        &        50 &      99 &                 100 \\
 hexforthree        & legal       &        50 &      71 &                 100 \\
 hexforthree        & terminal    &       100 &     100 &                 100 \\
 horseshoe          & next        &        57 &      93 &                  93 \\
 horseshoe          & goal        &        50 &      97 &                  95 \\
 horseshoe          & legal       &        50 &      98 &                 100 \\
 horseshoe          & terminal    &       100 &     100 &                 100 \\
 hunter             & next        &        52 &      95 &                  74 \\
 hunter             & goal        &        50 &      98 &                  99 \\
 hunter             & legal       &        50 &      99 &                -100 \\
 hunter             & terminal    &       100 &     100 &                 100 \\
 knights\_tour       & next        &        50 &      93 &                  50 \\
 knights\_tour       & goal        &        50 &      99 &                  99 \\
 knights\_tour       & legal       &        50 &      99 &                  97 \\
 knights\_tour       & terminal    &       100 &     100 &                 100 \\
 kono               & next        &        52 &      94 &                  83 \\
 kono               & goal        &        50 &      98 &                  97 \\
 kono               & legal       &        50 &      99 &                  99 \\
 kono               & terminal    &       100 &     100 &                 100 \\
 pentago            & next        &        52 &      99 &                  99 \\
 pentago            & goal        &        50 &      83 &                  64 \\
 pentago            & legal       &        50 &      97 &                  91 \\
 pentago            & terminal    &        50 &     100 &                 100 \\
 pilgrimage         & next        &        50 &      97 &                  88 \\
 pilgrimage         & goal        &        50 &      98 &                  96 \\
 pilgrimage         & legal       &        50 &      84 &                  86 \\
 pilgrimage         & terminal    &       100 &     100 &                 100 \\
 rainbow            & next        &        50 &      93 &                  87 \\
 rainbow            & goal        &        50 &      75 &                  50 \\
 rainbow            & legal       &        50 &      70 &                  27 \\
 rainbow            & terminal    &       100 &     100 &                 100 \\
 sudoku             & next        &        50 &      95 &                  82 \\
 sudoku             & goal        &        50 &      75 &                  50 \\
 sudoku             & legal       &        50 &      95 &                  10 \\
 sudoku             & terminal    &        50 &     100 &                  99 \\
 sukoshi            & next        &        50 &      87 &                  75 \\
 sukoshi            & goal        &        50 &      75 &                  50 \\
 sukoshi            & legal       &        50 &      91 &                  83 \\
 sukoshi            & terminal    &       100 &     100 &                 100 \\
 untwisty\_corridor  & next        &        57 &     100 &                 100 \\
 untwisty\_corridor  & goal        &        50 &      75 &                  50 \\
 untwisty\_corridor  & legal       &        50 &      50 &                   0 \\
 untwisty\_corridor  & terminal    &       100 &     100 &                 100 \\
\hline
\end{tabular}

		
\begin{tikzpicture}
\begin{axis}[
	x tick label style={
		/pgf/number format/1000 sep=},
	ylabel=Year,
	enlargelimits=0.05,
	legend style={at={(0.5,-0.1)},
	anchor=north,legend columns=-1},
	ybar interval=0.7,
]
\addplot 
	coordinates {(2012,408184) (2011,408348)
		 (2010,414870) (2009,412156)};
\addplot 
	coordinates {(2012,388950) (2011,393007) 
		(2010,398449) (2009,395972)};
\legend{Men,Women}
\end{axis}
\end{tikzpicture}
\section{Optimal Play vs Random with varying sample size}
\bibliography{project}
\bibliographystyle{plain}
\end{document}
